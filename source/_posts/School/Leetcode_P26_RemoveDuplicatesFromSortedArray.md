---
date: 2020-02-19 21:58:03
tags: School
title: Leetcode P26 删除排序数组中的重复项
---

# Leetcode P26 删除排序数组中的重复项

还是写学校作业，依然是 leetcode 简单题。

## 题目描述

给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。

不要使用额外的数组空间，你必须在原地修改输入数组并在使用 $O(1)$ 额外空间的条件下完成。

**示例 1**:

```
给定数组 nums = [1,1,2], 

函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。 

你不需要考虑数组中超出新长度后面的元素。
```

**示例 2**:

```
给定 nums = [0,0,1,1,1,2,2,3,3,4],

函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。

你不需要考虑数组中超出新长度后面的元素。
```

**说明**:

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。

## 一行代码的解法

这个问题很！简！单！就是过滤重复项嘛，这个问题在生活中很常见，我一般是用 `Set` 保证元素不重复的性质来解决这个问题的，具体实现是把列表转成集合再转回来就完成了。但这个题目还要要求排序，`Set` 不一定能保证有序性，那就再套一个排序好了。

虽然这个方法在时间、空间上消耗都不小，但代码十分简洁，emmmm，再利用合适的语言 + 一小点奇技淫巧，大概就一行代码：

Python3 解法：

```python
class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        nums[:] = sorted(set(nums))
```

> 执行用时 :248 ms, 在所有 Python3 提交中击败了11.22%的用户
>
> 内存消耗 :30.7 MB, 在所有 Python3 提交中击败了5.05%的用户

😂

但是这种方法有个小问题，在 Golang 里没有 `Set` 怎么办？用类似的思想，哈希表可以保证键唯一，把 `nums` 里的值做 key，全放入一个 `map` 里，迭代出来再排序也就完了。

---

以上纯属娱乐，下面开始正解：

## 双指针法

因为题目给的数组是已经排好序的，所以某一元素要么等于其前面一个元素，要么大于前面一个元素。

对某一元素，若等于前一元素，则说明改项重复，即需要“删除”。

我们不容易从数组中直接“删除”一个元素，但可以考虑用其他合适的元素来覆盖它。在这个问题中， 我们可以用一个不重复的元素来覆盖掉一个重复的元素。

所以，我们算法的思路就是：用指针 `i` 遍历数组，维护指针 `t` 保证 `t` 前的数组不重复，若 `i` 遍历到的元素不在 `t` 前的不重复部分（由于已经排序，也就是 `elementAt(i) != elementAt(t)` ），则将其加入（即用它覆盖 `t` 后一个元素，并且 `t` 自增 1）。

具体的实现上，，，emmm，我不想写了，直接抄一下题解吧。（难得自己的算法几乎和题解**一摸一样**）

> 数组完成排序后，我们可以放置两个指针 `i` 和 `j`，其中 `i` 是慢指针，而 `j` 是快指针。只要 `nums[i]=nums[j]`，我们就增加 `j` 以跳过重复项。当我们遇到 `nums[j] != nums[i]` 时，跳过重复项的运行已经结束，因此我们必须把它（`nums[j]`）的值复制到 `nums[i+1]`。然后递增 `i`，接着我们将再次重复相同的过程，直到 `j` 到达数组的末尾为止。
>
> 作者：LeetCode
> 链接：https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/solution/shan-chu-pai-xu-shu-zu-zhong-de-zhong-fu-xiang-by-/
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

Golang 实现：

```go
func removeDuplicates(nums []int) int {
    if len(nums) <= 1 {
        return len(nums)
    }
    t := 0
    for i := 1; i < len(nums); i++ {
        if nums[i] != nums[t] {
            t++
            nums[t] = nums[i]
        }
    }
    return t + 1
}
```

> 执行用时 :8 ms, 在所有 Go 提交中击败了93.95%的用户
>
> 内存消耗 :4.6 MB, 在所有 Go 提交中击败了62.06%的用户

---

吐槽一句，我不认为我写的比这没有缩进的丑陋 0 ms 的写的差！

![image-20200219213850376](https://tva1.sinaimg.cn/large/0082zybpgy1gc21h8o0kqj31to0n479r.jpg)

唯一的区别就是我把长度为 1 的也直接返回了，一个元素肯定也不重复嘛！但就多一个 `len()` 的调用我不认为可以把时间拉慢这么多，事实上，我把我的代码改成和他一模一样的依然是 8 ms。

还有在时间上，我跑了好几次，有的时候是 4.5 MB 击败 100%，有的时候是 4.6 MB 击败 62.06%。咱也不知道这个运气问题要怎么解决🤷‍♂️。

